---
title: Введение
---

Алгоритм шифрования RSA - это асимметричный алгоритм шифрования. RSA широко используется в шифровании с открытым ключом
и электронной коммерции. RSA был предложен в 1977 году Роном Ривестом, Ади Шамиром и Леонардом Адлеманом. RSA состоит из
букв трех имен троих из них.

Надежность алгоритма RSA определяется сложностью максимизации целочисленной факторизации. Другими словами, чем сложнее 
разложить на множители очень большое целое число, тем надежнее алгоритм RSA. Если кто-то найдет алгоритм быстрой 
факторизации, надежность информации, зашифрованной с помощью RSA, обязательно упадет. Но возможность найти такой 
алгоритм очень мала. Сегодня только короткие ключи RSA могут быть разрушены мощным способом. По состоянию на 2017 год не
существует надежного способа атаковать алгоритм RSA.

## Фундаментальный

### Генерация открытого и закрытого ключей

1. Случайным образом выберите два разных больших простых числа $p$ и $q$ для вычисления $N = p \times q$
2. В соответствии с функцией Эйлера найдите $\varphi (N)=\varphi (p)\varphi (q)=(p-1)(q-1)$
3. Выбрать целое число $e$ которое меньше, чем $\varphi (N)$ сделать $e$ и $\varphi (N)$ взаимно простыми. И спросите 
   $e$ об обратном $\varphi (N)$, именуемым $d$, такое что $ed\equiv 1 \pmod {\varphi (N)}$
4. Уничтожить $p$ и $q$

На этом этапе $(N,e)$ - открытый ключ и $(N,d)$ - закрытый ключ.

### Шифрование сообщений


Во-первых, нам нужно преобразовать сообщение в целое число $m$ с использованием согласованного протокола, например, $m$ 
меньше чем $N$ и $m$ взаимно простые с $N$. Если сообщение слишком длинное, мы можем разделить его на несколько 
сегментов, что мы называем блочным шифрованием, а затем зашифровать каждую часть по следующей формуле:

$$ m^{e}\equiv c\pmod N $$

### Расшифровка сообщения

Используйте закрытый ключ $d$, чтобы расшифровать сообщение.

$$ c^{d}\equiv m\pmod N $$

### Проверка

Проверять $m^{ed} \equiv m \bmod N$, воспользуемся тем, что $ed \equiv 1 \bmod \phi(N)$ тогда $ed=k\phi(N)+1$ достаточно
доказать, что

$$ m^{k\phi(N)+1} \equiv m \bmod N $$

Мы докажем это, рассмотрев два отдельных случая.

В первом случае $gcd(m,N)=1$, следовательно $m^{\phi(N)} \equiv 1 \bmod N$, так что первоначальное утверждение верно.

Во втором случае $gcd(m,N)\neq 1$, поэтому $m$ должно быть кратно $p$ или $q$, а поскольку $n=m$ меньше $N$, мы можем
предположить, что

$$ m = xp $$

Где $x$ должно быть меньше $q$. Поскольку $q$ - простое число,

$$ m^{\phi(q)}\equiv 1 \bmod q $$

$$ m^{k\phi(N)} = m {k(p-1)(q-1)} = (m^{\phi(q)})^{k(p-1)} \equiv 1 \bmod q $$

$$ m^{k\phi(N)+1}=m+uqm $$

$$ m^{k\phi(N)+1}=m+uqxp=m+uxN $$

Следовательно, это доказано.

## Основные инструменты

### RSA tool

- Установка
    ```bash
    git clone https://github.com/ius/rsatool.git
    cd rsatool
    python rsatool.py -h
    ```

- Сгенерировать закрытый ключ
    ```bash
    python rsatool.py f FEM private.pem o p q 1234567 7654321
    ```

### Конвертер RSA

- Создать pem-файл на основе заданной пары ключей
- Получать $p$ и $q$ из $n$, $e$, $d$

### Openssl

- Посмотреть файл открытого ключа
    ```shell
    openssl rsa -pubin -in pubkey.pem -text -modulus
    ```

- Расшифровка
    ```shell
    rsautl -decrypt -inkey private.pem -in flag.enc -out flag
    ```

Для получения более подробной информации, пожалуйста, обратитесь к `openssl --help`.

### Инструмент разложения целых чисел

- Декомпозиция сайта, [factor.db](<http://factordb.com/>)
- Декомпозиция командной строки, [factordb-pycli](<https://github.com/ryosan-470/factordb-pycli>), заимствование базы 
  данных factordb.
- [Яфу](<https://sourceforge.net/projects/yafu/>)

### Python

#### primefac

Библиотека целочисленной декомпозиции содержит множество алгоритмов целочисленной декомпозиции.

#### gmpy

- `gmpy.root(a, b)`, возвращает кортеж `(x, y)`, где `x` это открытое значение `a` степени `b`, `y` это суждение `x`, 
  является ли логическая переменная целым числом

#### gmpy2

При установке может потребоваться отдельно установить библиотеки mpfr и mpc.

- `gmpy2.iroot(a, b)`, схоже с `gmpy.root(a,b)`

#### pycrypto

- Установка
    ```bash
    sudo pip install pycrypto
    ```

- Использование
    ```python
    import gmpy
    from Crypto.Util.number import *
    from Crypto.PublicKey import RSA
    from Crypto.Cipher import PKCS1_v1_5


    msg = 'crypto here'
    p = getPrime(128)
    q = getPrime(128)
    n = p*q
    e = getPrime(64)
    pubkey = RSA.construct((long(n), long(e)))
    privatekey = RSA.construct((long(n), long(e), long(d), long(p), long(q)))
    key = PKCS1_v1_5.new(pubkey)
    enc = key.encrypt(msg).encode('base64')
    key = PKCS1_v1_5.new(privatekey)
    msg = key.decrypt(enc.decode('base64'), e)
    ```

## Example

??? example "Jarvis OJ - Basic - veryeasyRSA"
    ```text
    p = 3487583947589437589237958723892346254777 
    q = 8767867843568934765983476584376578389
    e = 65537
    Найти d =
    Пожалуйста, отправьте `PCTF{d}`
    ```

    Используя $ed\equiv 1 \pmod{\varphi(N)}$, вы можете получить $d$ из $\varphi (N)=\varphi (p)\varphi (q)=(p-1)(q-1)$.

    ```python
    from Crypto.Util.number import inverse
    
    
    p = 3487583947589437589237958723892346254777
    q = 8767867843568934765983476584376578389
    e = 65537
    phin = (p - 1) * (q - 1)
    print(inverse(e, phin))
    ```
    
    ```shell
    ➜  Jarvis OJ-Basic-veryeasyRSA git:(master) ✗ python exp.py       
    19178568796155560423675975774142829153827883709027717723363077606260717434369
    ```

??? example "2018 CodeGate CTF Rsababy"
    Программа представляет собой простой RSA, но программа также генерирует два странных числа.
    
    ```python
    e = 65537
    n = p * q
    pi_n = (p - 1) * (q - 1)
    d = mulinv(e, pi_n)
    h = (d + p) ^ (d - p)
    
    g = d * (p - 0xdeadbeef)
    ```

    Итак, проблема должна исходить отсюда, поэтому давайте начнем с нее, предположим, что `const = 0xdeadbeef.` потом

    $$ eg = ed * (p-const) $$

    Кроме того, по данным RSA

    $$ 2^{eg}=2^{ed * (p-const)}=2^{p-const} \pmod n $$
    
    $$ 2^{p-const} * 2^{const-1} = 2^{p-1} \pmod n $$

    Так
    
    $$ 2^{p-1} = 2^{eg} * 2^{const-1}+kn $$

    В то же время, согласно малой теореме Ферма, мы знаем
    
    $$ 2^{p-1} \equiv 1 \pmod p $$

    Так
    
    $$ p|2^{p-1}-1 | 2^{eg+const-1}-1+kn $$

    $$ p|2^{eg+const-1}-1 $$
    
    $$ p|gcd(2^{eg+const-1}-1,n) $$

    Следовательно, код выглядит следующим образом

    ```python
    tmp = pow(2, e * g + const - 1, n) - 1
    
    p = GCD(tmp, n)
    
    q = n // p
    
    Phin = (p - 1) * (q - 1)
    d = inverse(e, phin)
    plain = pow(data, d, n)
    
    print(long_to_bytes(plain))
    ```

??? example "2018 National Security Week pure math"
    Базовое описание темы такое

    ```text
    1) p ** p % q = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492
    2) q ** q % p = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323
    3) (p ** q + q ** p) % (p*q) = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406
    4) (p+q) ** (p+q) % (p*q) = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279
    5) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030
    А что такое ФЛАГ ???
    ```

    Наша цель - найти ФЛАГ, но как его найти? Этот вопрос требует от нас большего знакомства с теорией чисел.

    Исходя из содержания вопроса, можно предположить, что $p$, $q$ оба являются большими простыми числами, поэтому
    
    $$p^{q-1} \equiv 1\bmod q$$

    Тогда
    
    $$p^{q} \equiv p \bmod pq$$
    
    Из 3), мы знаем что

    $$p^q+q^p \equiv p+q \bmod pq$$
    
    И $p+q$ очевидно меньше чем $pq$, поэтому мы знаем значение $p+q$.
        
    Мы позволяем $x_1, x_2, x_3, x_4, x_5$ принимают значения от 1) до 5) соответственно.
    
    Из 4) имеем
    
    $$(p+q)^{p+q} \equiv p^{p+q}+q^{p+q} \bmod pq$$

    А в силу 1) и 2), то
    
    $$p^pp \equiv px_1\bmod pq$$
    
    $$q^qq \equiv qx_2 \bmod pq$$

    поэтому
    
    $$px_1+qx_2 \equiv x_4 \bmod pq$$
    
    Из того, как получены $x_1$ и $x_2$, мы знаем, что $px_1+qx_2$ оно также равно $x_4$, поэтому мы получаем систему 
    линейных уравнений с двумя переменными и можем решать ее напрямую.

    ```python
    from Crypto.Util.number import inverse, long_to_bytes
    
    
    x1 = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492
    x2 = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323
    p_q = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406
    x4 = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279
    
    if (x4 - x1 * p_q) % (x2 - x1) == 0:
        print('True')
    q = (x4 - x1 * p_q) / (x2 - x1)
    print(q)
    p = p_q - q
    
    c = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030
    
    phin = (p - 1) * (q - 1)
    d = inverse(31337, phin)
    flag = pow(c, d, p * q)
    print(long_to_bytes(flag))
    ```
    
    Флаг выглядит следующим образом
    
    ```shell
    ➜ 2018-National Security Week first game-puremath git:(master) ✗ python exp.py
    True
    7635093784603905632817000902311635311970645531806863592697496927519352405158721310359124595712780726701027634372170535318453656286180828724079479352052417
    flag{6a66b8d5-6047-4299-a48e-4c4d1f874d12}
    ```

??? example "2018 Pwnhub LHY"
    Флаг выглядит следующим образом

    ```python
    from Crypto.Util.number import isPrime
    assert isPrime(y) ** 2016 + isPrime(x + 1) ** 2017 + ((x ** 2 - 1) ** 2 % (2 * x * y - 1) + 2) ** 2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146
    ```
    
    Поскольку `isPrime` либо возвращает 1, либо возвращает 0, мы можем легко проверить, что `y` это простое число,
    $x+1$ также простое число, и

    $$(x^2-1)^2 \equiv 0 \bmod(2xy-1)$$
    
    Чтобы выражение было делимым, мы предполагаем, что $x=2y$.

    Итак, для следующего кода

    ```python
    from Crypto.Util.number import getPrime, inverse, bytes_to_long
    
    
    p = getPrime(x ** 3 + y ** 3)
    q = getPrime(x ** 2 * y + y ** 2 * x)
    n = p * q
    phi = (p - 1) * (q - 1)
    d = inverse(0x10001, phi)
    enc = pow(bytes_to_long(flag), 0x10001, n)
    print('n =', n)
    print('enc =', enc)
    ```
    
    $p$ и $q$ естественно
    
    $$p=getPrime(9y^3)$$
    
    $$q=getPrime(6y^3)$$

    В соответствии с интервалом простых чисел мы знаем, что $p$ и $q$ не больше, чем числа в скобках, и, как правило, не
    превышают $1000$.

    потом
    
    $$n \geq 54y^6$$

    Итак, мы знаем верхнюю границу $y$, а нижняя граница $y$ на самом деле не слишком далеко от верхней границы, мы, 
    вероятно, уменьшим сотни тысяч. Следовательно, мы используем двоичный поиск для поиска $p$ и $q$, как показано ниже,

    ```python
    import gmpy2
    
    tmp = 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146
    
    print(gmpy2.iroot(tmp, 2018))
    print(gmpy2.iroot(tmp - 1, 2018))
    print(gmpy2.iroot(tmp - 2, 2018))
    
    n = 260272753019642842691231717156206014402348296256668058656902033827190888150939144319270903947159599144884859205368557385941127216969379550487700198771513118894125094678559478972591331182960004648132846372455712958337042783083099376871113795475285658106058675217077803768944674144803250791799957440111855021945690877200606577646234107957498370758707097662736662439460472126493593605957225541979181422479704018055731221681621886820626215670393536343427267329350730257979042198593215747542270975288047196483958369426727778580292311145109908665004662296440533724591193527886702374790526322791818523938910660223971454070731594803459613066617828657725704376475527288174777197739360634209448477565044519733575375490101670974499385760735451471034271880800081246883157088501597655371430353965493264345172541221268942926210055390568364981514774743693528424196241142665685211916330254113610598390909248626686397970038848966187547231199741
    y = 191904757378974300059526915134037747982760255307942501070454569331878491189601823952845623286161325306079772871025816081849039036850918375408172174102720702781463514549851887084613000000L
    y = gmpy2.next_prime(y)
    
    enc = 73933313646416156737449236838459526871566017180178176765840447023088664788672323530940171469589918772272559607026808711216932468486201094786991159096267208480969757088208089800600731106685561375522764783335332964711981392251568543122418192877756299395774738176188452197889668610818741062203831272066261677731889616150485770623945568369493256759711422067551058418926344060504112146971937651406886327429318390247733970549845424064244469193626197360072341969574784310397213033860597822010667926563087858301337091484951760613299203587677078666096526093414014637559237148644939541419075479462431789925219269815364529507771308181435591670281081465439913711912925412078002618729159141400730636976744132429329651487292506365655834202469178066850282850374067239317928012461993443785247524500680257923687511378073703423047348824611101206633407452837948194591695712958510124436821151767823443033286425729473563002691262316964646014201612
    
    end = gmpy2.iroot(n / 54, 6)[0]
    beg = end - 2000000
    
    mid = 1
    while beg < end:
        mid = (beg + end) / 2
        if gmpy2.is_prime(mid) != 1:
            mid = gmpy2.next_prime(mid)
        p = gmpy2.next_prime(9 * mid ** 3)
        q = gmpy2.next_prime(6 * mid ** 3)
        n1 = p * q
        if n1 == n:
            print(p, q)
            phin = (p - 1) * (q - 1)
            d = gmpy2.invert(0x10001, phin)
            m = gmpy2.powmod(enc, d, n)
            print(hex(m)[2:].strip('L').decode('hex'))
            print('ok')
            exit(0)
        elif n1 < n:
            beg = mid
        else:
            end = mid
        print(beg, end)
    ```
