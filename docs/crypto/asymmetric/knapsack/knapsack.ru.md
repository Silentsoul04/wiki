---
title: Knapsack
---

## Проблема с рюкзаком

Во-первых, давайте познакомимся с проблемой рюкзака. Предположим, рюкзак может весить $W$. Теперь есть $n$ предметов с
весом $a_1, a_2,\ldots, a_n$. Мы хотим спросить, какие предметы подходят для рюкзака. Заполнено и каждый элемент можно
загрузить только один раз. Это фактически решает такую проблему.

$$x_1a_1 + x_2a_2 +, \ldots, + x_na_n = W$$

Все эти $x_i$ могут быть только $0$ и $1$. Очевидно, мы должны перечислить все комбинации из $n$ элементов, чтобы решить
эту проблему, а сложность составляет $2^n$, что является преимуществом шифрования рюкзака.

При шифровании, если мы хотим зашифровать открытый текст как $x$, мы можем представить его как `n`-битное двоичное 
число, а затем умножить его на $a_i$, чтобы получить зашифрованный результат.

Но что делать при расшифровке? Мы действительно затруднили расшифровку зашифрованного текста для других, но у нас
действительно нет возможности расшифровать зашифрованный текст.

Но когда $a_i$ супер-инкрементально, у нас есть решение. Так называемый супер-инкремент означает, что последовательность
удовлетворяет следующим условиям.

$$a_i>\sum_{k=1}^{i-1}a_k$$

То есть `i`-е число больше суммы всех предыдущих чисел.

Зачем его расшифровывать, если встречается такое условие? Это потому, что если зашифрованный результат больше, чем
$a_n$, предыдущий коэффициент должен быть $1$. Напротив, уравнение не может быть установлено в любом случае.
Следовательно, мы можем сразу получить соответствующий открытый текст.

Однако здесь есть другая проблема. Поскольку $a_i$ является общедоступным, если злоумышленник перехватит зашифрованный
текст, такой пароль легко взломать. Чтобы решить эту проблему, появляется алгоритм шифрования, такой как Меркл –
Хеллман. Мы можем использовать начальный набор пакетов в качестве закрытого ключа, преобразованный набор пакетов в
качестве открытого ключа, а затем немного изменить процесс шифрования.

Хотя здесь упоминается последовательность супер-приращения, не говорится, как она создается.

## Меркл – Хеллман

### Генерация публичного приватного ключа

#### Генерация закрытого ключа

Приватный ключ - это наш начальный рюкзак. Здесь мы используем последовательность супер-инкремента, как ее
сгенерировать? Мы можем предположить, что $a_1=1$, тогда $a_2$ больше $1$, и аналогично может генерировать последующие
значения по очереди.

#### Генерация открытого ключа

В процессе генерации открытого ключа в основном используется операция модульного умножения.

Сначала мы генерируем модуль m модульного умножения, здесь мы хотим убедиться, что

$$m>\sum_{i=1}^{i=n}a_i$$

Во-вторых, мы выбираем множитель w модульного умножения в качестве закрытого ключа и гарантируем

$$gcd(w,m)=1$$

После этого мы можем сгенерировать открытый ключ по следующей формуле.

$$b_i \equiv w a_i \bmod m$$

И этот новый рюкзак установил $b_i$ и $m$ в качестве открытого ключа.

### Шифрование и дешифрование

#### Шифрование

Предположим, мы хотим зашифровать открытый текст как $v$, каждый бит равен $v_i$, тогда результат нашего шифрования 
будет

$$\sum_{i=1}^{n}i=b_iv_i \ m way$$

#### Расшифровка

Что касается расшифровки, мы можем сначала запросить обратную величину $m^{-1}$ для $m$.

Затем мы можем умножить полученный зашифрованный текст на $w^{-1}$, чтобы получить открытый текст, потому что

$$\sum_ {i = 1} ^ {w} i = n ^ {- 1} b_iv_i \ way m = \ sum_ {i = 1} ^ {n} i = a_iv_i \ m way$$

здесь есть

$$b_i \equiv w a_i \bmod m$$

Зашифрованное сообщение для каждого блока меньше $m$, поэтому результат, естественно, является открытым текстом.

### Сломанный

Система была расшифрована через два года после предложенной системы шифрования. Основная идея дешифрования заключается в
том, что нам не обязательно находить правильный множитель $w$ (т.е. информацию о лазейке), просто найдите произвольный
модуль `m'`, и множитель `w'` можно использовать для генерации супер-увеличивающегося вектора рюкзака с помощью `w'`
умножить вектор рюкзака B.

### Примеры

??? example "Archaic in 2014 ASIS Cyber Security Contest"
    [ссылка на тему](<https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic>)

    Сначала посмотрите на исходную программу
    
    ```python
    secret = 'CENSORED'
    msg_bit = bin(int(secret.encode('hex'), 16))[2:]
    ```
    
    Сначала мы получаем все кусочки секрета.
    
    Во-вторых, используйте следующую функцию, чтобы получить пару ключей, включая открытый и закрытый ключи.
    
    ```python
    keyPair = makeKey(curtain(msg_bit))
    ```
    
    Тщательно проанализируйте функцию makekey следующим образом

    ```python
    import gmpy2
    import random
    
    
    def makeKey(n):
        priv_key = [random.randint(1, 4 ** n)]
        s = priv_key[0]
        for i in range(1, n):
            priv_key.append(random.randint(s + 1, 4 ** (n + i)))
            s += priv_key[i]
    
        q = random.randint(priv_key[n - 1] + 1, 2 * priv_key[n - 1])
        r = random.randint(1, q)
        while gmpy2.gcd(r, q) != 1:
            r = random.randint(1, q)
    
        pub_key = [r * w % q for w in priv_key]
        return priv_key, q, r, pub_key
    ```

    Можно видеть, что priv_key - это супер-инкрементная последовательность, и полученное $q$ больше суммы всех чисел в
    priv_key. Кроме того, мы получаем $r$, что в точности совпадает с $q$, что указывает на то, что шифрование является
    шифрованием рюкзака.
    
    Разумеется, функция шифрования состоит в умножении каждого бита сообщения на соответствующий открытый ключ и сумму.
    
    ```python
    def encrypt(msg, pub_key):
        cipher = 0
        for i, bit in enumerate(msg):
            cipher += int(bit) * pub_key[i]
        return bin(cipher)[2:]
    ```

    Для взломанного скрипта мы используем скрипт
    на [GitHub](<https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic>).
    Сделайте несколько простых изменений.

    ```python
    import binascii
    
    # open the public key and strip the spaces so we have a decent array
    fileKey = open('pub.Key', 'rb')
    pubKey = fileKey.read().replace(' ', '').replace('L', '').strip('[]').split(',')
    
    nbit = only(pubKey)
    
    # open the encoded message
    fileEnc = open('enc.txt', 'rb')
    encoded = fileEnc.read().replace('L', '')
    
    # create a large matrix of 0's (dimensions are public key length +1)
    A = Matrix(ZZ, nbit + 1, nbit + 1)
    
    # fill in the identity matrix
    
    for i in range(nbit):
        A[i, i] = 1
    
    # replace the bottom row with your public key
    for i in range(nbit):
        A[i, nbit] = pubKey[i]
    
    # last element is the encoded message
    A[nbit, nbit] = -int(encoded)
    res = A.LLL()
    
    for i in range(0, nbit + 1):
        M = res.row(i).list()
        flag = True
        for m in M:
            if m != 0 and m != 1:
                flag = False
                break
        if flag:
            print(i, M)
            M = ''.join(str(j) for j in M)
            # remove the last bit
            M = M[:-1]
            M = hex(int(M, 2))[2:-1]
            print(M)
    ```
    
    Декодируется после вывода
    
    ```text
    295 [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0]
    415349535f3962643364356664323432323638326331393536383830366130373036316365
    >>> import binascii
    >>> binascii.unhexlify('415349535f3962643364356664323432323638326331393536383830366130373036316365')
    'ASIS_9bd3d5fd2422682c19568806a07061ce'
    ```
    
    Следует отметить, что матрица res, полученная с помощью LLL-атаки, содержит только значение 01, это результат, 
    который мы хотим, потому что, когда мы шифруем открытый текст, он будет разложен на двоичные битовые строки. Кроме 
    того, нам нужно удалить последний номер соответствующей строки.